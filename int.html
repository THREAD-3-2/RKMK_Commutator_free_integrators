
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Algorithms &#8212; RKMK_Commutator_free_integrators 0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="MATLAB code" href="matlab.html" />
    <link rel="prev" title="Example" href="ode.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="algorithms">
<span id="int"></span><h1>Algorithms<a class="headerlink" href="#algorithms" title="Permalink to this heading">¶</a></h1>
<section id="runge-kutta-munthe-kaas-methods">
<span id="rkmk-int"></span><h2>Runge-Kutta-Munthe-Kaas methods<a class="headerlink" href="#runge-kutta-munthe-kaas-methods" title="Permalink to this heading">¶</a></h2>
<p>Lie group integrators solve differential equations whose solution evolve on a
manifold <span class="math notranslate nohighlight">\(\mathcal{M}\)</span>, i.e. the solution is a curve <span class="math notranslate nohighlight">\(y(t)\in\mathcal{M}\)</span>
whose tangent at any point coincides with a vector field <span class="math notranslate nohighlight">\(F\in\mathcal{X}(\mathcal{M})\)</span>
and passes through a designated initial value <span class="math notranslate nohighlight">\(y_0\)</span> at <span class="math notranslate nohighlight">\(t=t_0\)</span>:</p>
<div class="math notranslate nohighlight" id="equation-vecfield">
<span class="eqno">(1)<a class="headerlink" href="#equation-vecfield" title="Permalink to this equation">¶</a></span>\[\begin{align}
    \dot{y}(t) = F\left(y(t)\right),\qquad y(t_0)=y_0.
\end{align}\]</div>
<p>Notice that we restrict the discussion to the case of autonomous vector field (explicit time dependence
could easily be included). Let <span class="math notranslate nohighlight">\(G\)</span> be a Lie group acting transitively on <span class="math notranslate nohighlight">\(\mathcal{M}\)</span> via the
group action <span class="math notranslate nohighlight">\(\psi:G \times \mathcal{M} \rightarrow \mathcal{M}\)</span>, so
that <span class="math notranslate nohighlight">\(\mathcal{M}\)</span> is a homogeneous manifold. The underlying idea of Runge-Kutta-Munthe-Kaas
(RKMK) methods is to express a vector field <span class="math notranslate nohighlight">\(F\in\mathfrak{X}(\mathcal{M})\)</span> as
<span class="math notranslate nohighlight">\(F\vert_m = \psi_*(f(m))\vert_m\)</span> , where <span class="math notranslate nohighlight">\(\psi_*\)</span> is the infinitesimal generator
of <span class="math notranslate nohighlight">\(\psi\)</span> and <span class="math notranslate nohighlight">\(f:\mathcal{M}\rightarrow\mathfrak{g}\)</span>. This allows us to transform
the problem from the manifold <span class="math notranslate nohighlight">\(\mathcal{M}\)</span> to the Lie algebra <span class="math notranslate nohighlight">\(\mathfrak{g}\)</span>
of <span class="math notranslate nohighlight">\(G\)</span>, on which we can perform a time step integration with a Runge-Kutta method. We
then map the result back to <span class="math notranslate nohighlight">\(\mathcal{M}\)</span>, and repeat this up to the final integration time.
More explicitly, let <span class="math notranslate nohighlight">\(h_n\)</span> be the size of the <span class="math notranslate nohighlight">\(n-th\)</span> time step, we then update
<span class="math notranslate nohighlight">\(y_n\in\mathcal{M}\)</span> to <span class="math notranslate nohighlight">\(y_{n+1}\)</span> by</p>
<div class="math notranslate nohighlight" id="equation-int2">
<span class="eqno">(2)<a class="headerlink" href="#equation-int2" title="Permalink to this equation">¶</a></span>\[\begin{split}\begin{align}
    \begin{cases}
    \sigma(0) = 0\in\mathfrak{g},\\
    \dot{\sigma}(t) = \textrm{dexp}_{\sigma(t)}^{-1}\circ f\circ \psi \left(\exp(\sigma(t)),y_n\right)\in T_{\sigma(t)}\mathfrak{g}, \\
    y_{n+1} = \psi(\exp(\sigma_1),y_n)\in \mathcal{M},
    \end{cases}
\end{align}\end{split}\]</div>
<p>where  <span class="math notranslate nohighlight">\(\textrm{exp}:\mathfrak{g}\rightarrow G\)</span> is the exponential map,
and <span class="math notranslate nohighlight">\(\sigma_1\approx \sigma(h_n)\in\mathfrak{g}\)</span> is computed with a Runge-Kutta method.</p>
<p>The transformed differential equation for <span class="math notranslate nohighlight">\(\sigma(t)\)</span> makes use of the derivative of
the exponential mapping. The map <span class="math notranslate nohighlight">\(v\mapsto\textrm{dexp}_u(v)\)</span> is linear and invertible
when <span class="math notranslate nohighlight">\(u\)</span> belongs to some sufficiently small neighborhood of <span class="math notranslate nohighlight">\(0\in\mathfrak{g}\)</span>. It
has an expansion in nested Lie brackets and, using the operator <span class="math notranslate nohighlight">\(\textrm{ad}_u(v)=[u,v]\)</span>
and its powers <span class="math notranslate nohighlight">\(\textrm{ad}_u^2 v=[u,[u,v]]\)</span> etc, one can write</p>
<div class="math notranslate nohighlight" id="equation-int3">
<span class="eqno">(3)<a class="headerlink" href="#equation-int3" title="Permalink to this equation">¶</a></span>\[\begin{align}
    \textrm{dexp}_u(v) = \left.\frac{e^z-1}{z}\right|_{z=\textrm{ad}_u}(v) = v + \frac12[u,v] + \frac16[u,[u,v]] + \cdots.
\end{align}\]</div>
<p>The inverse is</p>
<div class="math notranslate nohighlight" id="equation-int4">
<span class="eqno">(4)<a class="headerlink" href="#equation-int4" title="Permalink to this equation">¶</a></span>\[\begin{align}
    \textrm{dexp}_u^{-1}(v) =\left.\frac{z}{e^z-1}\right|_{z=\textrm{ad}_u}(v)= v -\frac12[u,v] + \frac1{12}[u,[u,v]]+\cdots.
\end{align}\]</div>
<p>To evaluate <span class="math notranslate nohighlight">\(\textrm{dexp}_u^{-1}(v)\)</span> one can either truncate the series <span class="xref std std-ref">(3)</span>,
or compute its exact expression for the particular Lie algebra under consideration. The exponential
maps on the Lie groups SO(3) and SE(3) are implemented in
<a class="reference external" href="https://github.com/THREAD-3-2/RKMK_Commutator_free_integrators/blob/main/src/lie_group_functions/expSO3.m">expSO3</a>
and <a class="reference external" href="https://github.com/THREAD-3-2/RKMK_Commutator_free_integrators/blob/main/src/lie_group_functions/expSE3.m">expSE3</a>.
The exact expressions for the inverse of the derivative of
the exponential map on SO(3) and SE(3) are implemented
in <a class="reference external" href="https://github.com/THREAD-3-2/RKMK_Commutator_free_integrators/blob/main/src/lie_group_functions/dexpinvSO3.m">dexpinvSO3</a>
and <a class="reference external" href="https://github.com/THREAD-3-2/RKMK_Commutator_free_integrators/blob/main/src/lie_group_functions/dexpinvSE3.m">dexpinvSE3</a>.</p>
<section id="examples">
<span id="rkmk-ex-int"></span><h3>Examples<a class="headerlink" href="#examples" title="Permalink to this heading">¶</a></h3>
<p>Let us consider an s-stage Runge-Kutta (RK) method for the initial value problem <a class="reference internal" href="#equation-vecfield">(1)</a>:</p>
<div class="math notranslate nohighlight" id="equation-int5">
<span class="eqno">(5)<a class="headerlink" href="#equation-int5" title="Permalink to this equation">¶</a></span>\[\begin{align}
y_{n+1}=y_n+h \sum_{i=1}^s b_i k_i, \quad k_i=F\left(y_n+h \sum_{j=1}^s a_{i j} k_j \right), \quad i=1, \ldots, s,
\end{align}\]</div>
<p>where <span class="math notranslate nohighlight">\(b_i,\,a_{ij}\, (i,\,j=1,\dots\,s)\)</span> are real numbers called, respectively, the weights and coefficients of
the method, and <span class="math notranslate nohighlight">\(c_i=\sum_{j=1}^s a_{ij}\)</span> are called the nodes or abscissae. These constants define a specific RK method and can
be collected in the following table, known as Butcher’s tableau:</p>
<div class="math notranslate nohighlight" id="equation-int6">
<span class="eqno">(6)<a class="headerlink" href="#equation-int6" title="Permalink to this equation">¶</a></span>\[\begin{split}\begin{align}
\begin{array}{c|cccc}
c_1 &amp; a_{11} &amp; a_{12} &amp; \ldots &amp; a_{1 s} \\
c_2 &amp; a_{21} &amp; a_{22} &amp; \ldots &amp; a_{2 s} \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
c_s &amp; a_{s 1} &amp; a_{s 2} &amp; \ldots &amp; a_{s s} \\
\hline &amp; b_1 &amp; b_2 &amp; \ldots &amp; b_s
\end{array}
\end{align}\end{split}\]</div>
<p>From equation <a class="reference internal" href="#equation-int2">(2)</a> it follows that one step of the resulting Runge–Kutta–Munthe-Kaas method writes</p>
<div class="math notranslate nohighlight" id="equation-int7">
<span class="eqno">(7)<a class="headerlink" href="#equation-int7" title="Permalink to this equation">¶</a></span>\[\begin{split}\begin{align}
&amp;y_1=\exp \left(h \sum_{i=1}^s b_i k_i\right) \cdot y_0,\\
&amp;k_i=\operatorname{dexp}^{-1}_{h \sum_j a_{i j} k_j} f\left(\exp \left(h \sum_j a_{i j} k_j\right) \cdot y_0\right), \quad i=1, \ldots, s,
\end{align}\end{split}\]</div>
<p>where we denote the group action by “<span class="math notranslate nohighlight">\(\cdot\)</span>” for ease of notation.</p>
<p>The simplest Lie group integrator is the Lie-Euler method, based on the classical explicit Euler method, a first-order method with Butcher’s tableau given by</p>
<div class="math notranslate nohighlight" id="equation-int-0">
<span class="eqno">(8)<a class="headerlink" href="#equation-int-0" title="Permalink to this equation">¶</a></span>\[\begin{split}\begin{align}
\begin{array}{c|c}
0 &amp; 0 \\
\hline &amp; 1
\end{array}
\end{align}\end{split}\]</div>
<p>The resulting Lie-Euler method can be written as <span class="math notranslate nohighlight">\(y_{n+1}=\exp \left(h F(y_n)\right) y_n\)</span> and is implemenmted in
<a class="reference external" href="https://github.com/THREAD-3-2/RKMK_Commutator_free_integrators/blob/main/src/integrators/LieEuler.m">LieEuler</a>.</p>
<p>An improvement to the Lie-Euler method is the second-order RKMK method based on the tableau of the Heun’s method:</p>
<div class="math notranslate nohighlight" id="equation-int-1">
<span class="eqno">(9)<a class="headerlink" href="#equation-int-1" title="Permalink to this equation">¶</a></span>\[\begin{split}\begin{align}
\begin{array}{c|cc}
0 &amp; 0 &amp; 0 \\
1 &amp; 1 &amp; 0 \\
\hline &amp; 1/2 &amp; 1/2
\end{array}
\end{align}\end{split}\]</div>
<p>The resulting RKMK integrator is implemented in <a class="reference external" href="https://github.com/THREAD-3-2/RKMK_Commutator_free_integrators/blob/main/src/integrators/RKMK2Heun.m">RKMK2Heun</a></p>
<p>The following Butcher’s tables provide the coefficients for two classical methods of order three (on the left) and order four (on the right):</p>
<div class="math notranslate nohighlight" id="equation-4ord">
<span class="eqno">(10)<a class="headerlink" href="#equation-4ord" title="Permalink to this equation">¶</a></span>\[\begin{split}\begin{align}
\begin{array}{c|ccc}
0 &amp; 0 &amp; 0 &amp; 0 \\
{1/2} &amp; {1/2} &amp; 0 &amp; 0 \\
1 &amp; -1 &amp; 2 &amp; 0 \\
\hline &amp; {1/6} &amp; {2/3} &amp; {1/6}
\end{array}
\qquad \qquad \quad
\begin{array}{c|cccc}
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
{1/2} &amp; {1/2} &amp; 0 &amp; 0 &amp; 0 \\
{1/2} &amp; 0 &amp; {1/2} &amp; 0 &amp; 0 \\
1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
\hline &amp; {1/6} &amp; {1/3} &amp; {1/3} &amp; {1/6}
\end{array}
\end{align}\end{split}\]</div>
<p>The corresponding RKMK integrators are implemented in <a class="reference external" href="https://github.com/THREAD-3-2/RKMK_Commutator_free_integrators/blob/main/src/integrators/RKMK3.m">RKMK3</a> and
<a class="reference external" href="https://github.com/THREAD-3-2/RKMK_Commutator_free_integrators/blob/main/src/integrators/RKMK4.m">RKMK4</a>.</p>
</section>
</section>
<section id="commutator-free-methods">
<span id="cfree-int"></span><h2>Commutator-free methods<a class="headerlink" href="#commutator-free-methods" title="Permalink to this heading">¶</a></h2>
<p>The second class of Lie group integrators to be considered here are the commutator-free methods,
named this way to emphasize the contrast to RKMK schemes which usually include commutators in
the method format. These schemes include the Crouch-Grossman methods and have the format</p>
<div class="math notranslate nohighlight" id="equation-int-2">
<span class="eqno">(11)<a class="headerlink" href="#equation-int-2" title="Permalink to this equation">¶</a></span>\[\begin{split}\begin{align}
    Y_{n,r} &amp;= \exp\Big(h\sum_{k}\alpha_{r,J}^k f_{n,k}\Big)\cdots \exp\Big(h\sum_{k}\alpha_{r,1}^k f_{n,k}\Big) \cdot y_n\\
    f_{n,r} &amp;= f(Y_{n,r}) \\[1mm]
    y_{n+1} &amp;= \exp\Big(h\sum_k \beta_J^k f_{n,k}\Big)\cdots \exp\Big(h\sum_k \beta_1^k f_{n,k}\Big) \cdot y_n
\end{align}\end{split}\]</div>
<p>where “<span class="math notranslate nohighlight">\(\cdot\)</span>” denotes the group action. Here
the Runge-Kutta coefficients <span class="math notranslate nohighlight">\(\alpha_{r,j}^k\)</span>, <span class="math notranslate nohighlight">\(\beta_{j}^r\)</span> are related
to a classical Runge-Kutta scheme with coefficients <span class="math notranslate nohighlight">\(a_r^k\)</span>, <span class="math notranslate nohighlight">\(b_r\)</span> in
that <span class="math notranslate nohighlight">\(a_r^k=\sum_j \alpha_{r,j}^k\)</span> and <span class="math notranslate nohighlight">\(b_r=\sum_j \beta_{j}^r\)</span>.
The <span class="math notranslate nohighlight">\(\alpha_{r,j}^k\)</span>, <span class="math notranslate nohighlight">\(\beta_{j}^r\)</span> are usually chosen to obtain
computationally inexpensive schemes with the highest possible order of convergence.
The computational complexity of the above schemes depends on the cost of computing an
exponential as well as of evaluating the vector field. Therefore it makes sense to
keep the number of exponentials <span class="math notranslate nohighlight">\(J\)</span> in each stage as low as possible, and
possibly also the number of stages <span class="math notranslate nohighlight">\(s\)</span>.</p>
<p>The following example is a generalization of the classical fourth-order
Runge–Kutta method in <a class="reference internal" href="#equation-4ord">(10)</a> and is implemented in  <a class="reference external" href="https://github.com/THREAD-3-2/RKMK_Commutator_free_integrators/blob/main/src/integrators/CFree4.m">CFree4</a>:</p>
<div class="math notranslate nohighlight" id="equation-int-3">
<span class="eqno">(12)<a class="headerlink" href="#equation-int-3" title="Permalink to this equation">¶</a></span>\[\begin{split}\begin{aligned}
&amp;Y_1=y_0, \\
&amp;Y_2=\exp \left(\frac{1}{2} k_1\right) \cdot y_0, \\
&amp;Y_3=\exp \left(\frac{1}{2} k_2\right) \cdot y_0 \\
&amp;Y_4=\exp \left(k_3-\frac{1}{2} k_1\right) \cdot Y_2, \\
&amp;y_{\frac{1}{2}}=\exp \left(\frac{1}{12}\left(3 k_1+2 k_2+2 k_3-k_4\right)\right) \cdot y_0, \\
&amp;y_1=\exp \left(\frac{1}{12}\left(-k_1+2 k_2+2 k_3+3 k_4\right)\right) \cdot y_{\frac{1}{2}},
\end{aligned}\end{split}\]</div>
<p>with <span class="math notranslate nohighlight">\(k_i=hf(Y_i)\)</span>. We notice that one exponential is saved in computing <span class="math notranslate nohighlight">\(Y_4\)</span> by making use of <span class="math notranslate nohighlight">\(Y_2\)</span>. This shows that sometimes it is possible
to come up with tricks that allow to reuse exponentials from one stage to another, thereby lowering
the computational cost of the scheme.</p>
<p>We refer to <a class="reference external" href="https://doi.org/10.1080/00207160.2021.1966772">(Celledoni, Çokaj, Leone, Murari and Owren, 2021)</a>
and references cited therein for further details.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">RKMK_Commutator_free_integrators</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ode.html">Example</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#runge-kutta-munthe-kaas-methods">Runge-Kutta-Munthe-Kaas methods</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#commutator-free-methods">Commutator-free methods</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="matlab.html">MATLAB code</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="ode.html" title="previous chapter">Example</a></li>
      <li>Next: <a href="matlab.html" title="next chapter">MATLAB code</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Elena Celledoni, Ergys Çokaj, Andrea Leone, Davide Murari, Brynjulf Owren.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.1.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/int.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>